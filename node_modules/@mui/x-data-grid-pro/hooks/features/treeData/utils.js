"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault").default;
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildTreeDataPath = void 0;
exports.displaySetTreeDataPathWarning = displaySetTreeDataPathWarning;
exports.removeNodeFromSourceParent = removeNodeFromSourceParent;
exports.updateGroupHierarchyPaths = updateGroupHierarchyPaths;
exports.updateLeafPath = updateLeafPath;
exports.updateNodeParentAndDepth = updateNodeParentAndDepth;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _xDataGrid = require("@mui/x-data-grid");
var _warning = require("@mui/x-internals/warning");
var _utils = require("../rowReorder/utils");
const buildTreeDataPath = (node, tree) => {
  const path = [];
  let current = node;
  while (current && current.id !== _xDataGrid.GRID_ROOT_GROUP_ID) {
    if ((current.type === 'leaf' || current.type === 'group') && current.groupingKey !== null) {
      path.unshift(String(current.groupingKey));
    }
    current = tree[current.parent];
  }
  return path;
};
exports.buildTreeDataPath = buildTreeDataPath;
function displaySetTreeDataPathWarning(operationName) {
  (0, _warning.warnOnce)(`MUI X: ${operationName} requires \`setTreeDataPath()\` prop to update row data paths. ` + 'Please provide a `setTreeDataPath()` function to enable this feature.', 'warning');
}
function removeNodeFromSourceParent(updatedTree, sourceNode) {
  const sourceParent = updatedTree[sourceNode.parent];
  const sourceChildren = sourceParent.children.filter(id => id !== sourceNode.id);
  if (sourceChildren.length === 0) {
    updatedTree[sourceNode.parent] = (0, _extends2.default)({}, sourceParent, {
      type: 'leaf',
      children: undefined
    });
  } else {
    updatedTree[sourceNode.parent] = (0, _extends2.default)({}, sourceParent, {
      children: sourceChildren
    });
  }
}
async function updateLeafPath(sourceNode, targetPath, ctx) {
  const {
    apiRef,
    setTreeDataPath,
    processRowUpdate,
    onProcessRowUpdateError
  } = ctx;
  const dataRowIdToModelLookup = (0, _xDataGrid.gridRowsLookupSelector)(apiRef);
  const leafKey = sourceNode.type === 'leaf' ? sourceNode.groupingKey : null;
  const newPath = leafKey !== null ? [...targetPath, String(leafKey)] : targetPath;
  const originalRow = dataRowIdToModelLookup[sourceNode.id];
  const updatedRow = setTreeDataPath(newPath, originalRow);
  const updater = new _utils.BatchRowUpdater(apiRef, processRowUpdate, onProcessRowUpdateError);
  updater.queueUpdate(sourceNode.id, originalRow, updatedRow);
  const {
    successful,
    updates
  } = await updater.executeAll();
  if (successful.length === 0) {
    return null;
  }
  return updates[0];
}
async function updateGroupHierarchyPaths(sourceNode, sourceBasePath, targetPath, ctx) {
  const {
    apiRef,
    setTreeDataPath,
    processRowUpdate,
    onProcessRowUpdateError
  } = ctx;
  const rowTree = (0, _xDataGrid.gridRowTreeSelector)(apiRef);
  const dataRowIdToModelLookup = (0, _xDataGrid.gridRowsLookupSelector)(apiRef);
  const nodesToUpdate = (0, _utils.collectAllDescendants)(sourceNode, rowTree);
  nodesToUpdate.unshift(sourceNode); // Include the group itself

  const sourceDepth = sourceBasePath.length;
  const updater = new _utils.BatchRowUpdater(apiRef, processRowUpdate, onProcessRowUpdateError);
  for (const node of nodesToUpdate) {
    const originalRow = dataRowIdToModelLookup[node.id];
    const currentPath = buildTreeDataPath(node, rowTree);
    const relativePath = currentPath.slice(sourceDepth);
    const newPath = [...targetPath, ...relativePath];
    const updatedRow = setTreeDataPath(newPath, originalRow);
    updater.queueUpdate(node.id, originalRow, updatedRow);
  }
  const {
    successful,
    updates
  } = await updater.executeAll();
  if (successful.length === 0) {
    return [];
  }
  return updates;
}
function updateNodeParentAndDepth(updatedTree, node, newParentId, newDepth) {
  updatedTree[node.id] = (0, _extends2.default)({}, node, {
    parent: newParentId,
    depth: newDepth
  });
  if (node.type === 'group') {
    const depthDiff = newDepth - node.depth;
    (0, _utils.updateDescendantDepths)(node, updatedTree, depthDiff);
  }
}